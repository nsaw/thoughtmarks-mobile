import { ValidationSystem } from './ValidationSystem';
import { resetAllMocks } from '@/__tests__/helpers/test-utils';

// Mock fetch globally
global.fetch = jest.fn();

describe('ValidationSystem Integration', () => {
  let validationSystem: ValidationSystem;
  let mockFetch: jest.MockedFunction<typeof fetch>;

  beforeEach(() => {
    resetAllMocks();
    validationSystem = ValidationSystem.getInstance();
    mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;
  });

  afterEach(() => {
    validationSystem.destroy();
  });

  it('should handle validation in different environments', async () => {
    // Test in development environment
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({ status: 'ok', environment: 'development' }),
    } as any);

    const result = await validationSystem.validateEnvironment();
    
    if (process.env.NODE_ENV === 'development') {
      expect(result.isValid).toBe(true);
    } else {
      expect(result.isValid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
    }
  });

  it('should handle validation with performance monitoring', async () => {
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({ status: 'ok' }),
    } as any);

    const startTime = performance.now();
    const result = await validationSystem.validateEnvironment();
    const endTime = performance.now();
    
    expect(result.isValid).toBe(true);
    expect(result.duration).toBeGreaterThan(0);
    expect(endTime - startTime).toBeGreaterThan(0);
  });

  it('should handle concurrent validations with caching', async () => {
    mockFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ status: 'ok' }),
    } as any);

    // Run multiple validations concurrently
    const promises = [
      validationSystem.validateEnvironment(),
      validationSystem.validateEnvironment(),
      validationSystem.validateEnvironment(),
    ];

    const results = await Promise.all(promises);

    // All should succeed
    results.forEach(result => {
      expect(result.isValid).toBe(true);
    });

    // Should only make one network request due to caching
    expect(mockFetch).toHaveBeenCalledTimes(1);
  });

  it('should handle validation failures gracefully', async () => {
    mockFetch.mockRejectedValueOnce(new Error('Network error'));

    const result = await validationSystem.validateNetwork();
    
    expect(result.isValid).toBe(false);
    expect(result.errors.length).toBeGreaterThan(0);
    expect(result.errors.some(error => error.includes('Network error'))).toBe(true);
  });

  it('should provide comprehensive validation statistics', () => {
    const stats = validationSystem.getValidationStatistics();
    
    expect(stats).toHaveProperty('totalValidations');
    expect(stats).toHaveProperty('successfulValidations');
    expect(stats).toHaveProperty('failedValidations');
    expect(stats).toHaveProperty('averageValidationTime');
    expect(stats).toHaveProperty('cacheHitRate');
    expect(stats).toHaveProperty('retryCount');
  });

  it('should handle validation timeout scenarios', async () => {
    // Mock a slow network request
    mockFetch.mockImplementationOnce(() => 
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Timeout')), 100)
      )
    );

    const result = await validationSystem.validateEnvironment();
    
    expect(result.isValid).toBe(false);
    expect(result.errors.some(error => error.includes('timeout'))).toBe(true);
  }, 15000); // Increase timeout for this test

  it('should validate all system components', async () => {
    mockFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ status: 'ok' }),
    } as any);

    const validations = [
      validationSystem.validateEnvironment(),
      validationSystem.validateNetwork(),
      validationSystem.validatePlatform(),
    ];

    const results = await Promise.all(validations);

    results.forEach(result => {
      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });
  });
}); 