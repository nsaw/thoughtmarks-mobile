{
  "patchId": "patch-v1.4.410(P3.02.02)_core-hooks-implementation",
  "version": "v1.4.410",
  "phase": 3,
  "step": "3.02.02",
  "description": "Core Hooks Implementation",
  "priority": "high",
  "risk": "medium",
  "estimatedTime": "3-4 hours",
  "dependencies": [
    "patch-v1.4.410(P3.02.01)_core-types-definition"
  ],
  "validationGates": [
    "typescript",
    "eslint",
    "hook-testing",
    "dual-mount-toggle"
  ],
  "successCriteria": [
    "All core hooks properly implemented",
    "Hook testing passes",
    "No memory leaks",
    "Proper cleanup on unmount",
    "TypeScript compilation successful"
  ],
  "rollbackPlan": "Revert to basic hooks",
  "gitTag": "v1.4.410-P3.02.02",
  "summaryFile": "/Users/sawyer/gitSync/.cursor-cache/MAIN/summaries/patch-v1.4.410(P3.02.02)_core-hooks-implementation.md",
  "branch": "phase-3-core-hooks",
  "preMutationBuild": "npm run lint:guard && npx tsc --noEmit",
  "postMutationBuild": "npm run lint:guard && npx tsc --noEmit && npm run test:hooks",
  "mutations": [
    {
      "file": "mobile-native-fresh/src-nextgen/hooks/useApi.ts",
      "description": "Create API hook with proper TypeScript types",
      "content": "import { useState, useCallback, useRef } from 'react';\nimport { ApiResponse, ApiError, ApiRequestConfig } from '../types/ApiTypes';\n\nexport interface UseApiOptions<T> {\n  onSuccess?: (data: T) => void;\n  onError?: (error: ApiError) => void;\n  onFinally?: () => void;\n  immediate?: boolean;\n  retryCount?: number;\n  retryDelay?: number;\n}\n\nexport interface UseApiState<T> {\n  data: T | null;\n  loading: boolean;\n  error: ApiError | null;\n  isSuccess: boolean;\n  isError: boolean;\n}\n\nexport interface UseApiActions<T> {\n  execute: (config?: Partial<ApiRequestConfig>) => Promise<ApiResponse<T> | null>;\n  reset: () => void;\n  setData: (data: T) => void;\n  setError: (error: ApiError) => void;\n}\n\nexport function useApi<T = any>(\n  defaultConfig: ApiRequestConfig,\n  options: UseApiOptions<T> = {}\n): [UseApiState<T>, UseApiActions<T>] {\n  const [state, setState] = useState<UseApiState<T>>({\n    data: null,\n    loading: false,\n    error: null,\n    isSuccess: false,\n    isError: false,\n  });\n\n  const retryCountRef = useRef(0);\n  const { retryCount = 3, retryDelay = 1000 } = options;\n\n  const execute = useCallback(\n    async (config?: Partial<ApiRequestConfig>): Promise<ApiResponse<T> | null> => {\n      const finalConfig = { ...defaultConfig, ...config };\n      \n      setState(prev => ({ ...prev, loading: true, error: null, isError: false }));\n\n      try {\n        // Simulate API call - replace with actual API client\n        const response = await fetch(finalConfig.url, {\n          method: finalConfig.method,\n          headers: finalConfig.headers,\n          body: finalConfig.data ? JSON.stringify(finalConfig.data) : undefined,\n        });\n\n        const data = await response.json();\n\n        if (!response.ok) {\n          throw new Error(data.message || 'API request failed');\n        }\n\n        const apiResponse: ApiResponse<T> = {\n          data,\n          status: response.status,\n          message: 'Success',\n          success: true,\n          timestamp: new Date().toISOString(),\n        };\n\n        setState({\n          data,\n          loading: false,\n          error: null,\n          isSuccess: true,\n          isError: false,\n        });\n\n        options.onSuccess?.(data);\n        return apiResponse;\n      } catch (error) {\n        const apiError: ApiError = {\n          code: 'API_ERROR',\n          message: error instanceof Error ? error.message : 'Unknown error',\n          timestamp: new Date().toISOString(),\n        };\n\n        setState(prev => ({\n          ...prev,\n          loading: false,\n          error: apiError,\n          isSuccess: false,\n          isError: true,\n        }));\n\n        options.onError?.(apiError);\n\n        // Retry logic\n        if (retryCountRef.current < retryCount) {\n          retryCountRef.current++;\n          setTimeout(() => execute(config), retryDelay);\n        }\n\n        return null;\n      } finally {\n        options.onFinally?.();\n      }\n    },\n    [defaultConfig, options, retryCount, retryDelay]\n  );\n\n  const reset = useCallback(() => {\n    setState({\n      data: null,\n      loading: false,\n      error: null,\n      isSuccess: false,\n      isError: false,\n    });\n    retryCountRef.current = 0;\n  }, []);\n\n  const setData = useCallback((data: T) => {\n    setState(prev => ({ ...prev, data, isSuccess: true, isError: false }));\n  }, []);\n\n  const setError = useCallback((error: ApiError) => {\n    setState(prev => ({ ...prev, error, isSuccess: false, isError: true }));\n  }, []);\n\n  return [state, { execute, reset, setData, setError }];\n}"
    },
    {
      "file": "mobile-native-fresh/src-nextgen/hooks/useForm.ts",
      "description": "Create form hook with validation",
      "content": "import { useState, useCallback, useRef } from 'react';\nimport { FormState, FormConfig, FormActions, Validator } from '../types/FormTypes';\n\nexport function useForm<T extends Record<string, any>>(\n  config: FormConfig<T>\n): [FormState<T>, FormActions<T>] {\n  const [state, setState] = useState<FormState<T>>(() => {\n    const fields: Record<keyof T, any> = {} as any;\n    const errors: Record<keyof T, string> = {} as any;\n    const touched: Record<keyof T, boolean> = {} as any;\n\n    Object.keys(config.initialValues).forEach(key => {\n      fields[key] = {\n        name: key,\n        value: config.initialValues[key],\n        error: undefined,\n        touched: false,\n        required: false,\n      };\n      errors[key] = '';\n      touched[key] = false;\n    });\n\n    return {\n      fields,\n      isValid: true,\n      isDirty: false,\n      isSubmitting: false,\n      errors,\n      touched,\n    };\n  });\n\n  const initialValuesRef = useRef(config.initialValues);\n  const validationSchemaRef = useRef(config.validationSchema);\n\n  const validateField = useCallback(\n    async (name: keyof T, value: any, allValues?: T): Promise<string | undefined> => {\n      const validators = validationSchemaRef.current?.[name] || [];\n      \n      for (const validator of validators) {\n        const error = await validator(value, allValues);\n        if (error) return error;\n      }\n      \n      return undefined;\n    },\n    []\n  );\n\n  const validateForm = useCallback(async (): Promise<Record<keyof T, string>> => {\n    const allValues = Object.keys(state.fields).reduce((acc, key) => {\n      acc[key] = state.fields[key].value;\n      return acc;\n    }, {} as T);\n\n    const newErrors: Record<keyof T, string> = {} as any;\n    let isValid = true;\n\n    for (const key of Object.keys(state.fields)) {\n      const error = await validateField(key as keyof T, state.fields[key].value, allValues);\n      newErrors[key] = error || '';\n      if (error) isValid = false;\n    }\n\n    setState(prev => ({\n      ...prev,\n      errors: newErrors,\n      isValid,\n    }));\n\n    return newErrors;\n  }, [state.fields, validateField]);\n\n  const setFieldValue = useCallback(\n    async (name: keyof T, value: any) => {\n      setState(prev => {\n        const newFields = { ...prev.fields };\n        newFields[name] = { ...newFields[name], value };\n\n        const isDirty = Object.keys(newFields).some(\n          key => newFields[key].value !== initialValuesRef.current[key]\n        );\n\n        return {\n          ...prev,\n          fields: newFields,\n          isDirty,\n        };\n      });\n\n      if (config.validateOnChange) {\n        const error = await validateField(name, value);\n        setState(prev => ({\n          ...prev,\n          errors: { ...prev.errors, [name]: error || '' },\n        }));\n      }\n    },\n    [config.validateOnChange, validateField]\n  );\n\n  const setFieldError = useCallback((name: keyof T, error: string) => {\n    setState(prev => ({\n      ...prev,\n      errors: { ...prev.errors, [name]: error },\n    }));\n  }, []);\n\n  const setFieldTouched = useCallback(\n    async (name: keyof T, touched: boolean) => {\n      setState(prev => ({\n        ...prev,\n        fields: {\n          ...prev.fields,\n          [name]: { ...prev.fields[name], touched },\n        },\n        touched: { ...prev.touched, [name]: touched },\n      }));\n\n      if (touched && config.validateOnBlur) {\n        const error = await validateField(name, state.fields[name].value);\n        setState(prev => ({\n          ...prev,\n          errors: { ...prev.errors, [name]: error || '' },\n        }));\n      }\n    },\n    [config.validateOnBlur, validateField, state.fields]\n  );\n\n  const resetForm = useCallback(() => {\n    setState(prev => {\n      const newFields = { ...prev.fields };\n      Object.keys(newFields).forEach(key => {\n        newFields[key] = {\n          ...newFields[key],\n          value: initialValuesRef.current[key],\n          error: undefined,\n          touched: false,\n        };\n      });\n\n      return {\n        ...prev,\n        fields: newFields,\n        isValid: true,\n        isDirty: false,\n        errors: Object.keys(newFields).reduce((acc, key) => {\n          acc[key] = '';\n          return acc;\n        }, {} as Record<keyof T, string>),\n        touched: Object.keys(newFields).reduce((acc, key) => {\n          acc[key] = false;\n          return acc;\n        }, {} as Record<keyof T, boolean>),\n      };\n    });\n    config.onReset?.();\n  }, [config.onReset]);\n\n  const submitForm = useCallback(async () => {\n    setState(prev => ({ ...prev, isSubmitting: true }));\n\n    try {\n      const errors = await validateForm();\n      const hasErrors = Object.values(errors).some(error => error);\n\n      if (hasErrors) {\n        setState(prev => ({ ...prev, isSubmitting: false }));\n        return;\n      }\n\n      const values = Object.keys(state.fields).reduce((acc, key) => {\n        acc[key] = state.fields[key].value;\n        return acc;\n      }, {} as T);\n\n      await config.onSubmit(values);\n    } catch (error) {\n      console.error('Form submission error:', error);\n    } finally {\n      setState(prev => ({ ...prev, isSubmitting: false }));\n    }\n  }, [validateForm, state.fields, config.onSubmit]);\n\n  const getFieldValue = useCallback((name: keyof T) => {\n    return state.fields[name].value;\n  }, [state.fields]);\n\n  const getFieldError = useCallback((name: keyof T) => {\n    return state.errors[name] || undefined;\n  }, [state.errors]);\n\n  const getFieldTouched = useCallback((name: keyof T) => {\n    return state.touched[name];\n  }, [state.touched]);\n\n  return [\n    state,\n    {\n      setFieldValue,\n      setFieldError,\n      setFieldTouched,\n      resetForm,\n      submitForm,\n      validateForm,\n      getFieldValue,\n      getFieldError,\n      getFieldTouched,\n    },\n  ];\n}"
    },
    {
      "file": "mobile-native-fresh/src-nextgen/hooks/useDebounce.ts",
      "description": "Create debounce hook",
      "content": "import { useState, useEffect, useRef } from 'react';\n\nexport function useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n  const timeoutRef = useRef<NodeJS.Timeout>();\n\n  useEffect(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    timeoutRef.current = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\nexport function useDebouncedCallback<T extends (...args: any[]) => any>(\n  callback: T,\n  delay: number\n): T {\n  const timeoutRef = useRef<NodeJS.Timeout>();\n  const callbackRef = useRef(callback);\n\n  useEffect(() => {\n    callbackRef.current = callback;\n  }, [callback]);\n\n  const debouncedCallback = ((...args: any[]) => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    timeoutRef.current = setTimeout(() => {\n      callbackRef.current(...args);\n    }, delay);\n  }) as T;\n\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n\n  return debouncedCallback;\n}"
    },
    {
      "file": "mobile-native-fresh/src-nextgen/hooks/useThrottle.ts",
      "description": "Create throttle hook",
      "content": "import { useState, useEffect, useRef } from 'react';\n\nexport function useThrottle<T>(value: T, delay: number): T {\n  const [throttledValue, setThrottledValue] = useState<T>(value);\n  const lastRunRef = useRef<number>(Date.now());\n  const timeoutRef = useRef<NodeJS.Timeout>();\n\n  useEffect(() => {\n    const now = Date.now();\n\n    if (now - lastRunRef.current >= delay) {\n      setThrottledValue(value);\n      lastRunRef.current = now;\n    } else {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n\n      timeoutRef.current = setTimeout(() => {\n        setThrottledValue(value);\n        lastRunRef.current = Date.now();\n      }, delay - (now - lastRunRef.current));\n    }\n\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, [value, delay]);\n\n  return throttledValue;\n}\n\nexport function useThrottledCallback<T extends (...args: any[]) => any>(\n  callback: T,\n  delay: number\n): T {\n  const lastRunRef = useRef<number>(0);\n  const timeoutRef = useRef<NodeJS.Timeout>();\n  const callbackRef = useRef(callback);\n\n  useEffect(() => {\n    callbackRef.current = callback;\n  }, [callback]);\n\n  const throttledCallback = ((...args: any[]) => {\n    const now = Date.now();\n\n    if (now - lastRunRef.current >= delay) {\n      callbackRef.current(...args);\n      lastRunRef.current = now;\n    } else {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n\n      timeoutRef.current = setTimeout(() => {\n        callbackRef.current(...args);\n        lastRunRef.current = Date.now();\n      }, delay - (now - lastRunRef.current));\n    }\n  }) as T;\n\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n\n  return throttledCallback;\n}"
    },
    {
      "file": "mobile-native-fresh/src-nextgen/hooks/useLocalStorage.ts",
      "description": "Create local storage hook",
      "content": "import { useState, useEffect, useCallback } from 'react';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nexport function useLocalStorage<T>(key: string, initialValue: T) {\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    try {\n      return initialValue;\n    } catch (error) {\n      console.error(`Error reading localStorage key \"${key}\":`, error);\n      return initialValue;\n    }\n  });\n\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    const loadStoredValue = async () => {\n      try {\n        const item = await AsyncStorage.getItem(key);\n        if (item !== null) {\n          setStoredValue(JSON.parse(item));\n        }\n      } catch (error) {\n        console.error(`Error reading AsyncStorage key \"${key}\":`, error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    loadStoredValue();\n  }, [key]);\n\n  const setValue = useCallback(\n    async (value: T | ((val: T) => T)) => {\n      try {\n        const valueToStore = value instanceof Function ? value(storedValue) : value;\n        setStoredValue(valueToStore);\n        await AsyncStorage.setItem(key, JSON.stringify(valueToStore));\n      } catch (error) {\n        console.error(`Error setting AsyncStorage key \"${key}\":`, error);\n      }\n    },\n    [key, storedValue]\n  );\n\n  const removeValue = useCallback(async () => {\n    try {\n      setStoredValue(initialValue);\n      await AsyncStorage.removeItem(key);\n    } catch (error) {\n      console.error(`Error removing AsyncStorage key \"${key}\":`, error);\n    }\n  }, [key, initialValue]);\n\n  return [storedValue, setValue, removeValue, isLoading] as const;\n}"
    },
    {
      "file": "mobile-native-fresh/src-nextgen/hooks/index.ts",
      "description": "Update hooks index to export core hooks",
      "code_edit": "// ... existing code ...\nexport * from './useApi';\nexport * from './useForm';\nexport * from './useDebounce';\nexport * from './useThrottle';\nexport * from './useLocalStorage';\n\nexport {\n  useApi,\n  useForm,\n  useDebounce,\n  useDebouncedCallback,\n  useThrottle,\n  useThrottledCallback,\n  useLocalStorage,\n} from './useApi';\nexport { useForm } from './useForm';\nexport { useDebounce, useDebouncedCallback } from './useDebounce';\nexport { useThrottle, useThrottledCallback } from './useThrottle';\nexport { useLocalStorage } from './useLocalStorage';"
    }
  ]
} 