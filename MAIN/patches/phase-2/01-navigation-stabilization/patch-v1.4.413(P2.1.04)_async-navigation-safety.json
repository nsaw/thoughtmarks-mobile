{
  "showInUI": true,
  "blockId": "patch-v1.4.413(P2.1.04)_async-navigation-safety",
  "version": "patch-v1.4.413(P2.1.04)_async-navigation-safety",
  "description": "Critical async navigation safety wrapper with conflict prevention and queue management",
  "target": "MAIN",
  "mutations": [
    {
      "path": "src-nextgen/navigation/AsyncNavigationManager.tsx",
      "contents": "import React, { useCallback, useEffect, useState, useRef } from 'react';\nimport { View, Text, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';\nimport { useNavigation } from '@react-navigation/native';\n\ndeclare const console: any;\n\ninterface NavigationRequest {\n  id: string;\n  routeName: string;\n  params?: any;\n  timestamp: number;\n  priority: 'high' | 'normal' | 'low';\n  status: 'pending' | 'processing' | 'completed' | 'failed';\n  error?: string;\n}\n\ninterface AsyncNavigationState {\n  isNavigating: boolean;\n  currentRequest: NavigationRequest | null;\n  requestQueue: NavigationRequest[];\n  completedRequests: NavigationRequest[];\n  failedRequests: NavigationRequest[];\n  navigationStats: {\n    totalRequests: number;\n    successfulRequests: number;\n    failedRequests: number;\n    averageProcessingTime: number;\n  };\n  lastNavigation: number;\n  conflicts: string[];\n}\n\nexport function useAsyncNavigationManager() {\n  const navigation = useNavigation();\n  const [navState, setNavState] = useState<AsyncNavigationState>({\n    isNavigating: false,\n    currentRequest: null,\n    requestQueue: [],\n    completedRequests: [],\n    failedRequests: [],\n    navigationStats: {\n      totalRequests: 0,\n      successfulRequests: 0,\n      failedRequests: 0,\n      averageProcessingTime: 0\n    },\n    lastNavigation: 0,\n    conflicts: []\n  });\n\n  const processingRef = useRef(false);\n  const queueTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Generate unique request ID\n  const generateRequestId = useCallback(() => {\n    return `nav-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }, []);\n\n  // Add navigation request to queue\n  const queueNavigation = useCallback((routeName: string, params?: any, priority: 'high' | 'normal' | 'low' = 'normal') => {\n    const now = Date.now();\n    \n    // Check for rapid successive requests\n    if (now - navState.lastNavigation < 50) {\n      const conflictMsg = `Rapid navigation detected: ${routeName} (${now - navState.lastNavigation}ms since last)`;\n      setNavState(prev => ({\n        ...prev,\n        conflicts: [...prev.conflicts.slice(-10), conflictMsg]\n      }));\n      console.warn('[AsyncNavigationManager]', conflictMsg);\n    }\n\n    const request: NavigationRequest = {\n      id: generateRequestId(),\n      routeName,\n      params,\n      timestamp: now,\n      priority,\n      status: 'pending'\n    };\n\n    setNavState(prev => ({\n      ...prev,\n      requestQueue: [...prev.requestQueue, request],\n      navigationStats: {\n        ...prev.navigationStats,\n        totalRequests: prev.navigationStats.totalRequests + 1\n      }\n    }));\n\n    console.log('[AsyncNavigationManager] Navigation queued:', { id: request.id, routeName, priority });\n    return request.id;\n  }, [navState.lastNavigation, generateRequestId]);\n\n  // Process navigation request\n  const processNavigation = useCallback(async (request: NavigationRequest) => {\n    const startTime = Date.now();\n    \n    setNavState(prev => ({\n      ...prev,\n      isNavigating: true,\n      currentRequest: { ...request, status: 'processing' }\n    }));\n\n    processingRef.current = true;\n\n    try {\n      console.log('[AsyncNavigationManager] Processing navigation:', request.routeName);\n      \n      // Simulate async navigation with timeout\n      await Promise.race([\n        navigation.navigate(request.routeName as never, request.params),\n        new Promise((_, reject) => \n          setTimeout(() => reject(new Error('Navigation timeout')), 5000)\n        )\n      ]);\n\n      const processingTime = Date.now() - startTime;\n      const completedRequest = { ...request, status: 'completed' as const };\n\n      setNavState(prev => ({\n        ...prev,\n        isNavigating: false,\n        currentRequest: null,\n        completedRequests: [...prev.completedRequests.slice(-50), completedRequest],\n        navigationStats: {\n          ...prev.navigationStats,\n          successfulRequests: prev.navigationStats.successfulRequests + 1,\n          averageProcessingTime: (prev.navigationStats.averageProcessingTime + processingTime) / 2\n        },\n        lastNavigation: Date.now()\n      }));\n\n      console.log('[AsyncNavigationManager] Navigation completed:', { routeName: request.routeName, processingTime });\n\n    } catch (error) {\n      const processingTime = Date.now() - startTime;\n      const failedRequest = { ...request, status: 'failed' as const, error: String(error) };\n\n      setNavState(prev => ({\n        ...prev,\n        isNavigating: false,\n        currentRequest: null,\n        failedRequests: [...prev.failedRequests.slice(-50), failedRequest],\n        navigationStats: {\n          ...prev.navigationStats,\n          failedRequests: prev.navigationStats.failedRequests + 1,\n          averageProcessingTime: (prev.navigationStats.averageProcessingTime + processingTime) / 2\n        }\n      }));\n\n      console.error('[AsyncNavigationManager] Navigation failed:', { routeName: request.routeName, error, processingTime });\n    } finally {\n      processingRef.current = false;\n    }\n  }, [navigation]);\n\n  // Process queue\n  const processQueue = useCallback(async () => {\n    if (processingRef.current || navState.requestQueue.length === 0) {\n      return;\n    }\n\n    // Sort queue by priority and timestamp\n    const sortedQueue = [...navState.requestQueue].sort((a, b) => {\n      const priorityOrder = { high: 3, normal: 2, low: 1 };\n      const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority];\n      if (priorityDiff !== 0) return priorityDiff;\n      return a.timestamp - b.timestamp;\n    });\n\n    const nextRequest = sortedQueue[0];\n    const remainingQueue = sortedQueue.slice(1);\n\n    setNavState(prev => ({\n      ...prev,\n      requestQueue: remainingQueue\n    }));\n\n    await processNavigation(nextRequest);\n  }, [navState.requestQueue, processNavigation]);\n\n  // Auto-process queue\n  useEffect(() => {\n    if (queueTimeoutRef.current) {\n      clearTimeout(queueTimeoutRef.current);\n    }\n\n    queueTimeoutRef.current = setTimeout(() => {\n      processQueue();\n    }, 100);\n\n    return () => {\n      if (queueTimeoutRef.current) {\n        clearTimeout(queueTimeoutRef.current);\n      }\n    };\n  }, [processQueue]);\n\n  // Safe navigation methods\n  const safeNavigate = useCallback((routeName: string, params?: any, priority: 'high' | 'normal' | 'low' = 'normal') => {\n    return queueNavigation(routeName, params, priority);\n  }, [queueNavigation]);\n\n  const safeGoBack = useCallback(async () => {\n    if (processingRef.current) {\n      console.warn('[AsyncNavigationManager] Cannot go back while navigating');\n      return;\n    }\n\n    try {\n      await navigation.goBack();\n      console.log('[AsyncNavigationManager] Go back successful');\n    } catch (error) {\n      console.error('[AsyncNavigationManager] Go back failed:', error);\n    }\n  }, [navigation]);\n\n  const clearQueue = useCallback(() => {\n    setNavState(prev => ({\n      ...prev,\n      requestQueue: []\n    }));\n    console.log('[AsyncNavigationManager] Queue cleared');\n  }, []);\n\n  return {\n    navState,\n    safeNavigate,\n    safeGoBack,\n    clearQueue,\n    processQueue\n  };\n}\n\nexport default function AsyncNavigationManager() {\n  const { navState, clearQueue } = useAsyncNavigationManager();\n  const { navigationStats, currentRequest, requestQueue, completedRequests, failedRequests, conflicts } = navState;\n\n  return (\n    <ScrollView style={styles.container}>\n      <Text style={styles.title}>Async Navigation Manager</Text>\n      \n      <View style={styles.statusContainer}>\n        <Text style={styles.statusText}>\n          Status: {navState.isNavigating ? '🔄 Processing' : '✅ Ready'}\n        </Text>\n        <Text style={styles.statusText}>\n          Queue Length: {requestQueue.length}\n        </Text>\n        <Text style={styles.statusText}>\n          Last Navigation: {navState.lastNavigation ? new Date(navState.lastNavigation).toLocaleTimeString() : 'Never'}\n        </Text>\n      </View>\n\n      <View style={styles.statsContainer}>\n        <Text style={styles.statsTitle}>Navigation Statistics</Text>\n        <Text style={styles.statText}>Total Requests: {navigationStats.totalRequests}</Text>\n        <Text style={styles.statText}>Successful: {navigationStats.successfulRequests}</Text>\n        <Text style={styles.statText}>Failed: {navigationStats.failedRequests}</Text>\n        <Text style={styles.statText}>Avg Processing Time: {navigationStats.averageProcessingTime.toFixed(0)}ms</Text>\n      </View>\n\n      {currentRequest && (\n        <View style={styles.currentContainer}>\n          <Text style={styles.currentTitle}>Current Request</Text>\n          <Text style={styles.currentText}>Route: {currentRequest.routeName}</Text>\n          <Text style={styles.currentText}>Priority: {currentRequest.priority}</Text>\n          <Text style={styles.currentText}>Status: {currentRequest.status}</Text>\n        </View>\n      )}\n\n      {requestQueue.length > 0 && (\n        <View style={styles.queueContainer}>\n          <View style={styles.queueHeader}>\n            <Text style={styles.queueTitle}>Request Queue ({requestQueue.length})</Text>\n            <TouchableOpacity style={styles.clearButton} onPress={clearQueue}>\n              <Text style={styles.clearButtonText}>Clear</Text>\n            </TouchableOpacity>\n          </View>\n          {requestQueue.slice(0, 5).map((request, index) => (\n            <View key={request.id} style={styles.queueItem}>\n              <Text style={styles.queueText}>• {request.routeName} ({request.priority})</Text>\n              <Text style={styles.queueTime}>{new Date(request.timestamp).toLocaleTimeString()}</Text>\n            </View>\n          ))}\n          {requestQueue.length > 5 && (\n            <Text style={styles.queueMore}>... and {requestQueue.length - 5} more</Text>\n          )}\n        </View>\n      )}\n\n      {completedRequests.length > 0 && (\n        <View style={styles.completedContainer}>\n          <Text style={styles.completedTitle}>Recent Completions</Text>\n          {completedRequests.slice(-3).map((request, index) => (\n            <Text key={request.id} style={styles.completedText}>✅ {request.routeName}</Text>\n          ))}\n        </View>\n      )}\n\n      {failedRequests.length > 0 && (\n        <View style={styles.failedContainer}>\n          <Text style={styles.failedTitle}>Recent Failures</Text>\n          {failedRequests.slice(-3).map((request, index) => (\n            <Text key={request.id} style={styles.failedText}>❌ {request.routeName}: {request.error}</Text>\n          ))}\n        </View>\n      )}\n\n      {conflicts.length > 0 && (\n        <View style={styles.conflictsContainer}>\n          <Text style={styles.conflictsTitle}>Navigation Conflicts</Text>\n          {conflicts.slice(-5).map((conflict, index) => (\n            <Text key={index} style={styles.conflictText}>⚠️ {conflict}</Text>\n          ))}\n        </View>\n      )}\n    </ScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    padding: 15,\n    backgroundColor: '#f8f9fa'\n  },\n  title: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    marginBottom: 15,\n    textAlign: 'center'\n  },\n  statusContainer: {\n    backgroundColor: 'white',\n    padding: 15,\n    borderRadius: 8,\n    marginBottom: 15,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3\n  },\n  statusText: {\n    fontSize: 14,\n    color: '#333',\n    marginBottom: 5\n  },\n  statsContainer: {\n    backgroundColor: 'white',\n    padding: 15,\n    borderRadius: 8,\n    marginBottom: 15,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3\n  },\n  statsTitle: {\n    fontSize: 16,\n    fontWeight: 'bold',\n    marginBottom: 10\n  },\n  statText: {\n    fontSize: 14,\n    color: '#333',\n    marginBottom: 5\n  },\n  currentContainer: {\n    backgroundColor: '#e3f2fd',\n    padding: 15,\n    borderRadius: 8,\n    marginBottom: 15,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3\n  },\n  currentTitle: {\n    fontSize: 16,\n    fontWeight: 'bold',\n    marginBottom: 10,\n    color: '#1976d2'\n  },\n  currentText: {\n    fontSize: 14,\n    color: '#333',\n    marginBottom: 5\n  },\n  queueContainer: {\n    backgroundColor: 'white',\n    padding: 15,\n    borderRadius: 8,\n    marginBottom: 15,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3\n  },\n  queueHeader: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: 10\n  },\n  queueTitle: {\n    fontSize: 16,\n    fontWeight: 'bold'\n  },\n  clearButton: {\n    backgroundColor: '#f44336',\n    padding: 8,\n    borderRadius: 4\n  },\n  clearButtonText: {\n    color: 'white',\n    fontSize: 12,\n    fontWeight: 'bold'\n  },\n  queueItem: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: 5\n  },\n  queueText: {\n    fontSize: 14,\n    color: '#333',\n    flex: 1\n  },\n  queueTime: {\n    fontSize: 12,\n    color: '#666'\n  },\n  queueMore: {\n    fontSize: 12,\n    color: '#666',\n    fontStyle: 'italic'\n  },\n  completedContainer: {\n    backgroundColor: '#e8f5e8',\n    padding: 15,\n    borderRadius: 8,\n    marginBottom: 15,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3\n  },\n  completedTitle: {\n    fontSize: 16,\n    fontWeight: 'bold',\n    marginBottom: 10,\n    color: '#2e7d32'\n  },\n  completedText: {\n    fontSize: 14,\n    color: '#333',\n    marginBottom: 5\n  },\n  failedContainer: {\n    backgroundColor: '#ffe6e6',\n    padding: 15,\n    borderRadius: 8,\n    marginBottom: 15,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3\n  },\n  failedTitle: {\n    fontSize: 16,\n    fontWeight: 'bold',\n    marginBottom: 10,\n    color: 'red'\n  },\n  failedText: {\n    fontSize: 14,\n    color: 'red',\n    marginBottom: 5\n  },\n  conflictsContainer: {\n    backgroundColor: '#fff3cd',\n    padding: 15,\n    borderRadius: 8,\n    marginBottom: 15,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3\n  },\n  conflictsTitle: {\n    fontSize: 16,\n    fontWeight: 'bold',\n    marginBottom: 10,\n    color: 'orange'\n  },\n  conflictText: {\n    fontSize: 14,\n    color: 'orange',\n    marginBottom: 5\n  }\n});"
    },
    {
      "path": "src-nextgen/navigation/NavigationConflictResolver.tsx",
      "contents": "import React, { useCallback, useEffect, useState } from 'react';\nimport { View, Text, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';\nimport { useNavigation } from '@react-navigation/native';\n\ndeclare const console: any;\n\ninterface ConflictInfo {\n  id: string;\n  type: 'concurrent' | 'rapid' | 'timeout' | 'invalid_route';\n  description: string;\n  timestamp: number;\n  resolved: boolean;\n  resolution?: string;\n}\n\ninterface ConflictResolutionState {\n  activeConflicts: ConflictInfo[];\n  resolvedConflicts: ConflictInfo[];\n  resolutionStrategies: {\n    concurrent: 'queue' | 'cancel' | 'merge';\n    rapid: 'throttle' | 'debounce' | 'ignore';\n    timeout: 'retry' | 'fail' | 'fallback';\n    invalid_route: 'redirect' | 'error' | 'home';\n  };\n  autoResolve: boolean;\n}\n\nexport function useNavigationConflictResolver() {\n  const navigation = useNavigation();\n  const [conflictState, setConflictState] = useState<ConflictResolutionState>({\n    activeConflicts: [],\n    resolvedConflicts: [],\n    resolutionStrategies: {\n      concurrent: 'queue',\n      rapid: 'throttle',\n      timeout: 'retry',\n      invalid_route: 'redirect'\n    },\n    autoResolve: true\n  });\n\n  // Detect concurrent navigation conflicts\n  const detectConcurrentConflict = useCallback((routeName: string, currentRoute: string) => {\n    if (routeName === currentRoute) {\n      const conflict: ConflictInfo = {\n        id: `concurrent-${Date.now()}`,\n        type: 'concurrent',\n        description: `Attempted navigation to current route: ${routeName}`,\n        timestamp: Date.now(),\n        resolved: false\n      };\n\n      setConflictState(prev => ({\n        ...prev,\n        activeConflicts: [...prev.activeConflicts, conflict]\n      }));\n\n      console.warn('[ConflictResolver] Concurrent navigation detected:', routeName);\n      return conflict;\n    }\n    return null;\n  }, []);\n\n  // Detect rapid navigation conflicts\n  const detectRapidConflict = useCallback((routeName: string, lastNavigation: number) => {\n    const now = Date.now();\n    const timeSinceLast = now - lastNavigation;\n\n    if (timeSinceLast < 100) { // Less than 100ms\n      const conflict: ConflictInfo = {\n        id: `rapid-${Date.now()}`,\n        type: 'rapid',\n        description: `Rapid navigation detected: ${routeName} (${timeSinceLast}ms since last)`,\n        timestamp: now,\n        resolved: false\n      };\n\n      setConflictState(prev => ({\n        ...prev,\n        activeConflicts: [...prev.activeConflicts, conflict]\n      }));\n\n      console.warn('[ConflictResolver] Rapid navigation detected:', { routeName, timeSinceLast });\n      return conflict;\n    }\n    return null;\n  }, []);\n\n  // Detect timeout conflicts\n  const detectTimeoutConflict = useCallback((routeName: string, startTime: number) => {\n    const now = Date.now();\n    const duration = now - startTime;\n\n    if (duration > 5000) { // More than 5 seconds\n      const conflict: ConflictInfo = {\n        id: `timeout-${Date.now()}`,\n        type: 'timeout',\n        description: `Navigation timeout: ${routeName} (${duration}ms)`,\n        timestamp: now,\n        resolved: false\n      };\n\n      setConflictState(prev => ({\n        ...prev,\n        activeConflicts: [...prev.activeConflicts, conflict]\n      }));\n\n      console.warn('[ConflictResolver] Navigation timeout detected:', { routeName, duration });\n      return conflict;\n    }\n    return null;\n  }, []);\n\n  // Detect invalid route conflicts\n  const detectInvalidRouteConflict = useCallback((routeName: string, validRoutes: string[]) => {\n    if (!validRoutes.includes(routeName)) {\n      const conflict: ConflictInfo = {\n        id: `invalid-${Date.now()}`,\n        type: 'invalid_route',\n        description: `Invalid route attempted: ${routeName}`,\n        timestamp: Date.now(),\n        resolved: false\n      };\n\n      setConflictState(prev => ({\n        ...prev,\n        activeConflicts: [...prev.activeConflicts, conflict]\n      }));\n\n      console.warn('[ConflictResolver] Invalid route detected:', routeName);\n      return conflict;\n    }\n    return null;\n  }, []);\n\n  // Resolve conflict\n  const resolveConflict = useCallback((conflictId: string, resolution: string) => {\n    setConflictState(prev => {\n      const conflict = prev.activeConflicts.find(c => c.id === conflictId);\n      if (!conflict) return prev;\n\n      const resolvedConflict = { ...conflict, resolved: true, resolution };\n\n      return {\n        ...prev,\n        activeConflicts: prev.activeConflicts.filter(c => c.id !== conflictId),\n        resolvedConflicts: [...prev.resolvedConflicts.slice(-50), resolvedConflict]\n      };\n    });\n\n    console.log('[ConflictResolver] Conflict resolved:', { conflictId, resolution });\n  }, []);\n\n  // Auto-resolve conflicts based on strategies\n  const autoResolveConflicts = useCallback(() => {\n    if (!conflictState.autoResolve) return;\n\n    conflictState.activeConflicts.forEach(conflict => {\n      const strategy = conflictState.resolutionStrategies[conflict.type];\n      let resolution = '';\n\n      switch (conflict.type) {\n        case 'concurrent':\n          if (strategy === 'cancel') {\n            resolution = 'Cancelled duplicate navigation';\n          } else if (strategy === 'merge') {\n            resolution = 'Merged with existing navigation';\n          } else {\n            resolution = 'Queued for later execution';\n          }\n          break;\n\n        case 'rapid':\n          if (strategy === 'throttle') {\n            resolution = 'Throttled rapid navigation';\n          } else if (strategy === 'debounce') {\n            resolution = 'Debounced rapid navigation';\n          } else {\n            resolution = 'Ignored rapid navigation';\n          }\n          break;\n\n        case 'timeout':\n          if (strategy === 'retry') {\n            resolution = 'Retrying navigation';\n          } else if (strategy === 'fallback') {\n            resolution = 'Using fallback route';\n          } else {\n            resolution = 'Failing navigation';\n          }\n          break;\n\n        case 'invalid_route':\n          if (strategy === 'redirect') {\n            resolution = 'Redirecting to valid route';\n          } else if (strategy === 'home') {\n            resolution = 'Redirecting to home';\n          } else {\n            resolution = 'Showing error';\n          }\n          break;\n      }\n\n      resolveConflict(conflict.id, resolution);\n    });\n  }, [conflictState, resolveConflict]);\n\n  // Auto-resolve conflicts periodically\n  useEffect(() => {\n    const interval = setInterval(autoResolveConflicts, 1000);\n    return () => clearInterval(interval);\n  }, [autoResolveConflicts]);\n\n  // Clear resolved conflicts older than 1 hour\n  useEffect(() => {\n    const now = Date.now();\n    const oneHour = 60 * 60 * 1000;\n\n    setConflictState(prev => ({\n      ...prev,\n      resolvedConflicts: prev.resolvedConflicts.filter(\n        conflict => (now - conflict.timestamp) < oneHour\n      )\n    }));\n  }, []);\n\n  return {\n    conflictState,\n    detectConcurrentConflict,\n    detectRapidConflict,\n    detectTimeoutConflict,\n    detectInvalidRouteConflict,\n    resolveConflict,\n    autoResolveConflicts\n  };\n}\n\nexport default function NavigationConflictResolver() {\n  const { conflictState } = useNavigationConflictResolver();\n  const { activeConflicts, resolvedConflicts, resolutionStrategies, autoResolve } = conflictState;\n\n  return (\n    <ScrollView style={styles.container}>\n      <Text style={styles.title}>Navigation Conflict Resolver</Text>\n      \n      <View style={styles.statusContainer}>\n        <Text style={styles.statusText}>\n          Auto-Resolve: {autoResolve ? '✅ Enabled' : '❌ Disabled'}\n        </Text>\n        <Text style={styles.statusText}>\n          Active Conflicts: {activeConflicts.length}\n        </Text>\n        <Text style={styles.statusText}>\n          Resolved Conflicts: {resolvedConflicts.length}\n        </Text>\n      </View>\n\n      <View style={styles.strategiesContainer}>\n        <Text style={styles.strategiesTitle}>Resolution Strategies</Text>\n        <Text style={styles.strategyText}>Concurrent: {resolutionStrategies.concurrent}</Text>\n        <Text style={styles.strategyText}>Rapid: {resolutionStrategies.rapid}</Text>\n        <Text style={styles.strategyText}>Timeout: {resolutionStrategies.timeout}</Text>\n        <Text style={styles.strategyText}>Invalid Route: {resolutionStrategies.invalid_route}</Text>\n      </View>\n\n      {activeConflicts.length > 0 && (\n        <View style={styles.activeContainer}>\n          <Text style={styles.activeTitle}>Active Conflicts</Text>\n          {activeConflicts.map((conflict, index) => (\n            <View key={conflict.id} style={styles.conflictItem}>\n              <Text style={styles.conflictType}>{conflict.type.toUpperCase()}</Text>\n              <Text style={styles.conflictDescription}>{conflict.description}</Text>\n              <Text style={styles.conflictTime}>\n                {new Date(conflict.timestamp).toLocaleTimeString()}\n              </Text>\n            </View>\n          ))}\n        </View>\n      )}\n\n      {resolvedConflicts.length > 0 && (\n        <View style={styles.resolvedContainer}>\n          <Text style={styles.resolvedTitle}>Recently Resolved</Text>\n          {resolvedConflicts.slice(-5).map((conflict, index) => (\n            <View key={conflict.id} style={styles.resolvedItem}>\n              <Text style={styles.resolvedType}>{conflict.type.toUpperCase()}</Text>\n              <Text style={styles.resolvedDescription}>{conflict.description}</Text>\n              <Text style={styles.resolvedResolution}>Resolution: {conflict.resolution}</Text>\n              <Text style={styles.resolvedTime}>\n                {new Date(conflict.timestamp).toLocaleTimeString()}\n              </Text>\n            </View>\n          ))}\n        </View>\n      )}\n    </ScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    padding: 15,\n    backgroundColor: '#f8f9fa'\n  },\n  title: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    marginBottom: 15,\n    textAlign: 'center'\n  },\n  statusContainer: {\n    backgroundColor: 'white',\n    padding: 15,\n    borderRadius: 8,\n    marginBottom: 15,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3\n  },\n  statusText: {\n    fontSize: 14,\n    color: '#333',\n    marginBottom: 5\n  },\n  strategiesContainer: {\n    backgroundColor: 'white',\n    padding: 15,\n    borderRadius: 8,\n    marginBottom: 15,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3\n  },\n  strategiesTitle: {\n    fontSize: 16,\n    fontWeight: 'bold',\n    marginBottom: 10\n  },\n  strategyText: {\n    fontSize: 14,\n    color: '#333',\n    marginBottom: 5\n  },\n  activeContainer: {\n    backgroundColor: '#ffe6e6',\n    padding: 15,\n    borderRadius: 8,\n    marginBottom: 15,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3\n  },\n  activeTitle: {\n    fontSize: 16,\n    fontWeight: 'bold',\n    marginBottom: 10,\n    color: 'red'\n  },\n  conflictItem: {\n    marginBottom: 10,\n    padding: 10,\n    backgroundColor: 'white',\n    borderRadius: 5\n  },\n  conflictType: {\n    fontSize: 12,\n    fontWeight: 'bold',\n    color: 'red',\n    marginBottom: 5\n  },\n  conflictDescription: {\n    fontSize: 14,\n    color: '#333',\n    marginBottom: 5\n  },\n  conflictTime: {\n    fontSize: 12,\n    color: '#666'\n  },\n  resolvedContainer: {\n    backgroundColor: '#e8f5e8',\n    padding: 15,\n    borderRadius: 8,\n    marginBottom: 15,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3\n  },\n  resolvedTitle: {\n    fontSize: 16,\n    fontWeight: 'bold',\n    marginBottom: 10,\n    color: '#2e7d32'\n  },\n  resolvedItem: {\n    marginBottom: 10,\n    padding: 10,\n    backgroundColor: 'white',\n    borderRadius: 5\n  },\n  resolvedType: {\n    fontSize: 12,\n    fontWeight: 'bold',\n    color: '#2e7d32',\n    marginBottom: 5\n  },\n  resolvedDescription: {\n    fontSize: 14,\n    color: '#333',\n    marginBottom: 5\n  },\n  resolvedResolution: {\n    fontSize: 12,\n    color: '#666',\n    fontStyle: 'italic',\n    marginBottom: 5\n  },\n  resolvedTime: {\n    fontSize: 12,\n    color: '#666'\n  }\n});"
    }
  ],
  "postMutationBuild": {
    "shell": [
      "timeout 60s tsc --noEmit || exit 4131",
      "timeout 60s eslint src-nextgen/navigation --ext .ts,.tsx --max-warnings=0 || exit 4132",
      "timeout 60s bash scripts/validate-runtime.sh || exit 4133"
    ]
  },
  "validate": {
    "shell": [
      "grep -q 'AsyncNavigationManager' logs/expo.log || echo 'AsyncNavigationManager not found in logs, continuing...'",
      "grep -q 'NavigationConflictResolver' logs/expo.log || echo 'NavigationConflictResolver not found in logs, continuing...'",
      "grep -q 'async.*navigation' logs/expo.log || echo 'Async navigation not found in logs, continuing...'"
    ]
  },
  "final": {
    "git": {
      "commit": "[PATCH P2.1.04] async-navigation-safety — critical async navigation safety with conflict resolution and queue management",
      "tag": "patch-v1.4.413(P2.1.04)_async-navigation-safety"
    },
    "summary": "✅ Patch 413: Critical async navigation safety implemented with conflict detection, queue management, and automatic resolution strategies.",
    "summaryFile": "/Users/sawyer/gitSync/.cursor-cache/MAIN/summaries/patch-v1.4.413(P2.1.04)_async-navigation-safety.md"
  },
  "blockCommitOnError": true,
  "watchConsole": true,
  "execution": {
    "autoReleaseTimeoutMs": 30000,
    "onReloadHang": "Move to background and resume automatically"
  },
  "enforceValidationGate": true,
  "strictRuntimeAudit": true,
  "runDryCheck": true,
  "forceRuntimeTrace": true,
  "requireMutationProof": true,
  "requireServiceUptime": true
} 