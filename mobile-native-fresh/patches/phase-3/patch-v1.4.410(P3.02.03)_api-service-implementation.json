{
  "patchId": "patch-v1.4.410(P3.02.03)_api-service-implementation",
  "version": "v1.4.410",
  "phase": 3,
  "step": "3.02.03",
  "description": "API Service Implementation",
  "priority": "high",
  "risk": "medium",
  "estimatedTime": "2-3 hours",
  "dependencies": [
    "patch-v1.4.410(P3.02.01)_core-types-definition",
    "patch-v1.4.410(P3.02.02)_core-hooks-implementation"
  ],
  "validationGates": [
    "typescript",
    "eslint",
    "api-testing",
    "dual-mount-toggle"
  ],
  "successCriteria": [
    "API service properly implemented",
    "All API endpoints defined",
    "Error handling working",
    "Authentication integration",
    "API tests pass"
  ],
  "rollbackPlan": "Revert to basic API calls",
  "gitTag": "v1.4.410-P3.02.03",
  "summaryFile": "/Users/sawyer/gitSync/.cursor-cache/MAIN/summaries/patch-v1.4.410(P3.02.03)_api-service-implementation.md",
  "branch": "phase-3-api-service",
  "preMutationBuild": "npm run lint:guard && npx tsc --noEmit",
  "postMutationBuild": "npm run lint:guard && npx tsc --noEmit && npm run test:api",
  "mutations": [
    {
      "file": "mobile-native-fresh/src-nextgen/services/api/ApiClient.ts",
      "description": "Create API client with proper TypeScript types",
      "content": "import { ApiResponse, ApiError, ApiRequestConfig, ApiClient as IApiClient } from '../../types/ApiTypes';\n\nexport class ApiClient implements IApiClient {\n  private baseURL: string;\n  private defaultHeaders: Record<string, string>;\n  private timeout: number;\n  private retryCount: number;\n  private retryDelay: number;\n\n  constructor(config: {\n    baseURL: string;\n    timeout?: number;\n    retryCount?: number;\n    retryDelay?: number;\n    defaultHeaders?: Record<string, string>;\n  }) {\n    this.baseURL = config.baseURL;\n    this.timeout = config.timeout || 10000;\n    this.retryCount = config.retryCount || 3;\n    this.retryDelay = config.retryDelay || 1000;\n    this.defaultHeaders = {\n      'Content-Type': 'application/json',\n      ...config.defaultHeaders,\n    };\n  }\n\n  private async makeRequest<T>(\n    config: ApiRequestConfig,\n    attempt: number = 0\n  ): Promise<ApiResponse<T>> {\n    try {\n      const url = config.url.startsWith('http') ? config.url : `${this.baseURL}${config.url}`;\n      \n      const headers = {\n        ...this.defaultHeaders,\n        ...config.headers,\n      };\n\n      const requestConfig: RequestInit = {\n        method: config.method,\n        headers,\n        body: config.data ? JSON.stringify(config.data) : undefined,\n      };\n\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n      const response = await fetch(url, {\n        ...requestConfig,\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        throw new Error(data.message || `HTTP ${response.status}`);\n      }\n\n      return {\n        data,\n        status: response.status,\n        message: 'Success',\n        success: true,\n        timestamp: new Date().toISOString(),\n      };\n    } catch (error) {\n      if (attempt < this.retryCount && this.shouldRetry(error)) {\n        await this.delay(this.retryDelay * Math.pow(2, attempt));\n        return this.makeRequest<T>(config, attempt + 1);\n      }\n\n      throw this.createApiError(error);\n    }\n  }\n\n  private shouldRetry(error: any): boolean {\n    if (error.name === 'AbortError') return false;\n    if (error.message?.includes('HTTP 5')) return true;\n    if (error.message?.includes('HTTP 429')) return true;\n    return false;\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  private createApiError(error: any): ApiError {\n    return {\n      code: error.code || 'API_ERROR',\n      message: error.message || 'Unknown error occurred',\n      details: error.details || error,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  async request<T>(config: ApiRequestConfig): Promise<ApiResponse<T>> {\n    return this.makeRequest<T>(config);\n  }\n\n  async get<T>(url: string, params?: Record<string, any>): Promise<ApiResponse<T>> {\n    const queryString = params ? `?${new URLSearchParams(params).toString()}` : '';\n    return this.makeRequest<T>({\n      method: 'GET',\n      url: `${url}${queryString}`,\n    });\n  }\n\n  async post<T>(url: string, data?: any): Promise<ApiResponse<T>> {\n    return this.makeRequest<T>({\n      method: 'POST',\n      url,\n      data,\n    });\n  }\n\n  async put<T>(url: string, data?: any): Promise<ApiResponse<T>> {\n    return this.makeRequest<T>({\n      method: 'PUT',\n      url,\n      data,\n    });\n  }\n\n  async delete<T>(url: string): Promise<ApiResponse<T>> {\n    return this.makeRequest<T>({\n      method: 'DELETE',\n      url,\n    });\n  }\n\n  async patch<T>(url: string, data?: any): Promise<ApiResponse<T>> {\n    return this.makeRequest<T>({\n      method: 'PATCH',\n      url,\n      data,\n    });\n  }\n\n  setAuthToken(token: string): void {\n    this.defaultHeaders.Authorization = `Bearer ${token}`;\n  }\n\n  removeAuthToken(): void {\n    delete this.defaultHeaders.Authorization;\n  }\n\n  setBaseURL(baseURL: string): void {\n    this.baseURL = baseURL;\n  }\n}"
    },
    {
      "file": "mobile-native-fresh/src-nextgen/services/api/AuthService.ts",
      "description": "Create authentication service",
      "content": "import { ApiClient } from './ApiClient';\nimport { User } from '../../types/DataTypes';\nimport { ApiResponse } from '../../types/ApiTypes';\n\nexport interface LoginCredentials {\n  email: string;\n  password: string;\n}\n\nexport interface RegisterData {\n  email: string;\n  password: string;\n  name: string;\n}\n\nexport interface AuthResponse {\n  user: User;\n  token: string;\n  refreshToken: string;\n  expiresAt: string;\n}\n\nexport interface PasswordResetRequest {\n  email: string;\n}\n\nexport interface PasswordResetConfirm {\n  token: string;\n  password: string;\n}\n\nexport class AuthService {\n  private apiClient: ApiClient;\n\n  constructor(apiClient: ApiClient) {\n    this.apiClient = apiClient;\n  }\n\n  async login(credentials: LoginCredentials): Promise<ApiResponse<AuthResponse>> {\n    const response = await this.apiClient.post<AuthResponse>('/auth/login', credentials);\n    if (response.success) {\n      this.apiClient.setAuthToken(response.data.token);\n    }\n    return response;\n  }\n\n  async register(data: RegisterData): Promise<ApiResponse<AuthResponse>> {\n    const response = await this.apiClient.post<AuthResponse>('/auth/register', data);\n    if (response.success) {\n      this.apiClient.setAuthToken(response.data.token);\n    }\n    return response;\n  }\n\n  async logout(): Promise<ApiResponse<void>> {\n    try {\n      await this.apiClient.post<void>('/auth/logout');\n    } finally {\n      this.apiClient.removeAuthToken();\n    }\n    return {\n      data: undefined,\n      status: 200,\n      message: 'Logged out successfully',\n      success: true,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  async refreshToken(refreshToken: string): Promise<ApiResponse<AuthResponse>> {\n    const response = await this.apiClient.post<AuthResponse>('/auth/refresh', {\n      refreshToken,\n    });\n    if (response.success) {\n      this.apiClient.setAuthToken(response.data.token);\n    }\n    return response;\n  }\n\n  async requestPasswordReset(data: PasswordResetRequest): Promise<ApiResponse<void>> {\n    return this.apiClient.post<void>('/auth/password-reset', data);\n  }\n\n  async confirmPasswordReset(data: PasswordResetConfirm): Promise<ApiResponse<void>> {\n    return this.apiClient.post<void>('/auth/password-reset/confirm', data);\n  }\n\n  async getCurrentUser(): Promise<ApiResponse<User>> {\n    return this.apiClient.get<User>('/auth/me');\n  }\n\n  async updateProfile(updates: Partial<User>): Promise<ApiResponse<User>> {\n    return this.apiClient.put<User>('/auth/profile', updates);\n  }\n\n  async changePassword(data: {\n    currentPassword: string;\n    newPassword: string;\n  }): Promise<ApiResponse<void>> {\n    return this.apiClient.post<void>('/auth/change-password', data);\n  }\n}"
    },
    {
      "file": "mobile-native-fresh/src-nextgen/services/api/ThoughtmarkService.ts",
      "description": "Create thoughtmark service",
      "content": "import { ApiClient } from './ApiClient';\nimport { Thoughtmark, Bin } from '../../types/DataTypes';\nimport { ApiResponse } from '../../types/ApiTypes';\n\nexport interface CreateThoughtmarkData {\n  title: string;\n  content: string;\n  tags: string[];\n  binId: string;\n}\n\nexport interface UpdateThoughtmarkData extends Partial<CreateThoughtmarkData> {\n  id: string;\n}\n\nexport interface ThoughtmarkFilters {\n  binId?: string;\n  tags?: string[];\n  search?: string;\n  isArchived?: boolean;\n  isPinned?: boolean;\n  sortBy?: 'created' | 'updated' | 'title';\n  sortOrder?: 'asc' | 'desc';\n  limit?: number;\n  offset?: number;\n}\n\nexport interface CreateBinData {\n  name: string;\n  description?: string;\n  color: string;\n}\n\nexport interface UpdateBinData extends Partial<CreateBinData> {\n  id: string;\n}\n\nexport class ThoughtmarkService {\n  private apiClient: ApiClient;\n\n  constructor(apiClient: ApiClient) {\n    this.apiClient = apiClient;\n  }\n\n  // Thoughtmark operations\n  async getThoughtmarks(filters?: ThoughtmarkFilters): Promise<ApiResponse<Thoughtmark[]>> {\n    return this.apiClient.get<Thoughtmark[]>('/thoughtmarks', filters);\n  }\n\n  async getThoughtmark(id: string): Promise<ApiResponse<Thoughtmark>> {\n    return this.apiClient.get<Thoughtmark>(`/thoughtmarks/${id}`);\n  }\n\n  async createThoughtmark(data: CreateThoughtmarkData): Promise<ApiResponse<Thoughtmark>> {\n    return this.apiClient.post<Thoughtmark>('/thoughtmarks', data);\n  }\n\n  async updateThoughtmark(data: UpdateThoughtmarkData): Promise<ApiResponse<Thoughtmark>> {\n    const { id, ...updateData } = data;\n    return this.apiClient.put<Thoughtmark>(`/thoughtmarks/${id}`, updateData);\n  }\n\n  async deleteThoughtmark(id: string): Promise<ApiResponse<void>> {\n    return this.apiClient.delete<void>(`/thoughtmarks/${id}`);\n  }\n\n  async archiveThoughtmark(id: string): Promise<ApiResponse<Thoughtmark>> {\n    return this.apiClient.patch<Thoughtmark>(`/thoughtmarks/${id}/archive`);\n  }\n\n  async unarchiveThoughtmark(id: string): Promise<ApiResponse<Thoughtmark>> {\n    return this.apiClient.patch<Thoughtmark>(`/thoughtmarks/${id}/unarchive`);\n  }\n\n  async pinThoughtmark(id: string): Promise<ApiResponse<Thoughtmark>> {\n    return this.apiClient.patch<Thoughtmark>(`/thoughtmarks/${id}/pin`);\n  }\n\n  async unpinThoughtmark(id: string): Promise<ApiResponse<Thoughtmark>> {\n    return this.apiClient.patch<Thoughtmark>(`/thoughtmarks/${id}/unpin`);\n  }\n\n  async moveThoughtmark(id: string, binId: string): Promise<ApiResponse<Thoughtmark>> {\n    return this.apiClient.patch<Thoughtmark>(`/thoughtmarks/${id}/move`, { binId });\n  }\n\n  async searchThoughtmarks(query: string, filters?: Omit<ThoughtmarkFilters, 'search'>): Promise<ApiResponse<Thoughtmark[]>> {\n    return this.apiClient.get<Thoughtmark[]>('/thoughtmarks/search', {\n      ...filters,\n      search: query,\n    });\n  }\n\n  // Bin operations\n  async getBins(): Promise<ApiResponse<Bin[]>> {\n    return this.apiClient.get<Bin[]>('/bins');\n  }\n\n  async getBin(id: string): Promise<ApiResponse<Bin>> {\n    return this.apiClient.get<Bin>(`/bins/${id}`);\n  }\n\n  async createBin(data: CreateBinData): Promise<ApiResponse<Bin>> {\n    return this.apiClient.post<Bin>('/bins', data);\n  }\n\n  async updateBin(data: UpdateBinData): Promise<ApiResponse<Bin>> {\n    const { id, ...updateData } = data;\n    return this.apiClient.put<Bin>(`/bins/${id}`, updateData);\n  }\n\n  async deleteBin(id: string): Promise<ApiResponse<void>> {\n    return this.apiClient.delete<void>(`/bins/${id}`);\n  }\n\n  async reorderBins(binIds: string[]): Promise<ApiResponse<Bin[]>> {\n    return this.apiClient.post<Bin[]>('/bins/reorder', { binIds });\n  }\n}"
    },
    {
      "file": "mobile-native-fresh/src-nextgen/services/api/TaskService.ts",
      "description": "Create task service",
      "content": "import { ApiClient } from './ApiClient';\nimport { Task } from '../../types/DataTypes';\nimport { ApiResponse } from '../../types/ApiTypes';\n\nexport interface CreateTaskData {\n  title: string;\n  description?: string;\n  priority: 'low' | 'medium' | 'high';\n  dueDate?: string;\n  tags?: string[];\n}\n\nexport interface UpdateTaskData extends Partial<CreateTaskData> {\n  id: string;\n}\n\nexport interface TaskFilters {\n  isCompleted?: boolean;\n  priority?: 'low' | 'medium' | 'high';\n  tags?: string[];\n  dueDate?: {\n    start?: string;\n    end?: string;\n  };\n  sortBy?: 'created' | 'updated' | 'dueDate' | 'priority' | 'title';\n  sortOrder?: 'asc' | 'desc';\n  limit?: number;\n  offset?: number;\n}\n\nexport class TaskService {\n  private apiClient: ApiClient;\n\n  constructor(apiClient: ApiClient) {\n    this.apiClient = apiClient;\n  }\n\n  async getTasks(filters?: TaskFilters): Promise<ApiResponse<Task[]>> {\n    return this.apiClient.get<Task[]>('/tasks', filters);\n  }\n\n  async getTask(id: string): Promise<ApiResponse<Task>> {\n    return this.apiClient.get<Task>(`/tasks/${id}`);\n  }\n\n  async createTask(data: CreateTaskData): Promise<ApiResponse<Task>> {\n    return this.apiClient.post<Task>('/tasks', data);\n  }\n\n  async updateTask(data: UpdateTaskData): Promise<ApiResponse<Task>> {\n    const { id, ...updateData } = data;\n    return this.apiClient.put<Task>(`/tasks/${id}`, updateData);\n  }\n\n  async deleteTask(id: string): Promise<ApiResponse<void>> {\n    return this.apiClient.delete<void>(`/tasks/${id}`);\n  }\n\n  async completeTask(id: string): Promise<ApiResponse<Task>> {\n    return this.apiClient.patch<Task>(`/tasks/${id}/complete`);\n  }\n\n  async uncompleteTask(id: string): Promise<ApiResponse<Task>> {\n    return this.apiClient.patch<Task>(`/tasks/${id}/uncomplete`);\n  }\n\n  async assignTask(id: string, userId: string): Promise<ApiResponse<Task>> {\n    return this.apiClient.patch<Task>(`/tasks/${id}/assign`, { userId });\n  }\n\n  async unassignTask(id: string): Promise<ApiResponse<Task>> {\n    return this.apiClient.patch<Task>(`/tasks/${id}/unassign`);\n  }\n\n  async getTasksByDueDate(startDate: string, endDate: string): Promise<ApiResponse<Task[]>> {\n    return this.apiClient.get<Task[]>('/tasks/by-due-date', {\n      startDate,\n      endDate,\n    });\n  }\n\n  async getOverdueTasks(): Promise<ApiResponse<Task[]>> {\n    return this.apiClient.get<Task[]>('/tasks/overdue');\n  }\n\n  async getTasksByPriority(priority: 'low' | 'medium' | 'high'): Promise<ApiResponse<Task[]>> {\n    return this.apiClient.get<Task[]>(`/tasks/by-priority/${priority}`);\n  }\n}"
    },
    {
      "file": "mobile-native-fresh/src-nextgen/services/api/index.ts",
      "description": "Create API services index",
      "content": "export * from './ApiClient';\nexport * from './AuthService';\nexport * from './ThoughtmarkService';\nexport * from './TaskService';\n\nexport { ApiClient } from './ApiClient';\nexport { AuthService } from './AuthService';\nexport { ThoughtmarkService } from './ThoughtmarkService';\nexport { TaskService } from './TaskService';"
    },
    {
      "file": "mobile-native-fresh/src-nextgen/services/api/ApiClient.test.ts",
      "description": "Create tests for API client",
      "content": "import { ApiClient } from './ApiClient';\n\n// Mock fetch\nglobal.fetch = jest.fn();\n\nconst mockFetch = fetch as jest.MockedFunction<typeof fetch>;\n\ndescribe('ApiClient', () => {\n  let apiClient: ApiClient;\n\n  beforeEach(() => {\n    apiClient = new ApiClient({\n      baseURL: 'https://api.example.com',\n      timeout: 5000,\n    });\n    jest.clearAllMocks();\n  });\n\n  it('should make GET request successfully', async () => {\n    const mockResponse = { data: 'test', status: 200 };\n    mockFetch.mockResolvedValueOnce({\n      ok: true,\n      status: 200,\n      json: async () => mockResponse,\n    } as Response);\n\n    const result = await apiClient.get('/test');\n\n    expect(result.success).toBe(true);\n    expect(result.data).toEqual(mockResponse);\n    expect(mockFetch).toHaveBeenCalledWith(\n      'https://api.example.com/test',\n      expect.objectContaining({\n        method: 'GET',\n        headers: expect.objectContaining({\n          'Content-Type': 'application/json',\n        }),\n      })\n    );\n  });\n\n  it('should make POST request with data', async () => {\n    const mockResponse = { id: 1, name: 'test' };\n    const postData = { name: 'test' };\n\n    mockFetch.mockResolvedValueOnce({\n      ok: true,\n      status: 201,\n      json: async () => mockResponse,\n    } as Response);\n\n    const result = await apiClient.post('/test', postData);\n\n    expect(result.success).toBe(true);\n    expect(result.data).toEqual(mockResponse);\n    expect(mockFetch).toHaveBeenCalledWith(\n      'https://api.example.com/test',\n      expect.objectContaining({\n        method: 'POST',\n        body: JSON.stringify(postData),\n      })\n    );\n  });\n\n  it('should handle API errors', async () => {\n    const errorResponse = { message: 'Not found' };\n    mockFetch.mockResolvedValueOnce({\n      ok: false,\n      status: 404,\n      json: async () => errorResponse,\n    } as Response);\n\n    await expect(apiClient.get('/test')).rejects.toThrow('Not found');\n  });\n\n  it('should retry on 5xx errors', async () => {\n    const successResponse = { data: 'success' };\n    \n    mockFetch\n      .mockResolvedValueOnce({\n        ok: false,\n        status: 500,\n        json: async () => ({ message: 'Internal server error' }),\n      } as Response)\n      .mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () => successResponse,\n      } as Response);\n\n    const result = await apiClient.get('/test');\n\n    expect(result.success).toBe(true);\n    expect(mockFetch).toHaveBeenCalledTimes(2);\n  });\n\n  it('should set auth token', () => {\n    const token = 'test-token';\n    apiClient.setAuthToken(token);\n\n    expect(apiClient['defaultHeaders'].Authorization).toBe(`Bearer ${token}`);\n  });\n\n  it('should remove auth token', () => {\n    apiClient.setAuthToken('test-token');\n    apiClient.removeAuthToken();\n\n    expect(apiClient['defaultHeaders'].Authorization).toBeUndefined();\n  });\n});"
    }
  ]
} 