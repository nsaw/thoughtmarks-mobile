#!/usr/bin/env { { { { node

import { SUMMARY_WRITE_DIR, SUMMARY_ARCHIVE_DIR & &  & } >/dev/null 2>&1 & disown & } >/dev/null 2>&1 & disown} >/dev/null 2>&1 & disown} >/dev/null 2>&1 & disown} from './constants/paths.js';
import fs from 'fs';
import path from 'path';

/**
 * GHOST 2.x Unified Summary Writer
 * Writes summaries to .cursor-cache/CYOPS/summaries/
 */

class SummaryWriter {
    constructor() {
        this.writeDir = SUMMARY_WRITE_DIR;
        this.archiveDir = SUMMARY_ARCHIVE_DIR;
        
        // Ensure directories exist
        this.ensureDirectories();
    }

    ensureDirectories() {
        if (!fs.existsSync(this.writeDir)) {
            fs.mkdirSync(this.writeDir, { recursive: true });
            console.log(`üìÅ Created summary write directory: ${this.writeDir}`);
        }
        
        if (!fs.existsSync(this.archiveDir)) {
            fs.mkdirSync(this.archiveDir, { recursive: true });
            console.log(`üìÅ Created summary archive directory: ${this.archiveDir}`);
        }
    }

    /**
     * Write a summary to the unified directory
     */
    writeSummary(filename, content, metadata = {}) {
        try {
            const filePath = path.join(this.writeDir, filename);
            
            // Add metadata to content
            const enhancedContent = this.addMetadata(content, metadata);
            
            fs.writeFileSync(filePath, enhancedContent, 'utf8');
            console.log(`üìÑ Summary written: ${filename}`);
            
            return {
                success: true,
                path: filePath,
                filename: filename
            };
        } catch (error) {
            console.error(`‚ùå Error writing summary ${filename}:`, error.message);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Write patch execution summary
     */
    writePatchSummary(patchData, executionResult) {
        const timestamp = new Date().toISOString();
        const filename = `summary-${patchData.id || 'unknown'}-${Date.now()}.md`;
        
        const content = `# Patch Execution Summary

**Patch ID**: ${patchData.id || 'N/A'}
**Version**: ${patchData.version || 'N/A'}
**Description**: ${patchData.description || 'N/A'}
**Executed At**: ${timestamp}

## Execution Details
- **Status**: ${executionResult.success ? '‚úÖ Success' : '‚ùå Failed'}
- **Duration**: ${executionResult.duration || 'N/A'}ms
- **Actions Executed**: ${executionResult.actionsExecuted || 0}
- **Build Commands**: ${executionResult.buildCommands || 0}

## Results
${executionResult.success ? '‚úÖ Patch executed successfully' : '‚ùå Patch execution failed'}

## Metadata
- **Environment**: GHOST 2.x Unified
- **Writer**: BRAUN Summary Writer
- **Routing**: .cursor-cache/CYOPS/summaries/

---
*Generated by GHOST 2.x Unified Summary Writer*
`;

        return this.writeSummary(filename, content, {
            type: 'patch-execution',
            patchId: patchData.id,
            version: patchData.version,
            timestamp: timestamp
        });
    }

    /**
     * Write system status summary
     */
    writeSystemSummary(systemStatus) {
        const timestamp = new Date().toISOString();
        const filename = `system-status-${Date.now()}.md`;
        
        const content = `# System Status Summary

**Generated At**: ${timestamp}

## Active Systems
${Object.entries(systemStatus.active || {}).map(([system, status]) => 
    `- **${system}**: ${status ? '‚úÖ Running' : '‚ùå Stopped'}`
).join('\n')}

## Patch Status
- **Pending**: ${systemStatus.pendingPatches || 0}
- **Completed**: ${systemStatus.completedPatches || 0}
- **Failed**: ${systemStatus.failedPatches || 0}

## GHOST Integration
- **Status**: ${systemStatus.ghostStatus || 'Unknown'}
- **Last Check**: ${systemStatus.lastGhostCheck || 'N/A'}

## Routing Status
- **Patch Watch**: .cursor-cache/MAIN/patches/
- **Summary Write**: .cursor-cache/CYOPS/summaries/
- **Unified Routing**: ‚úÖ Active

---
*Generated by GHOST 2.x Unified Summary Writer*
`;

        return this.writeSummary(filename, content, {
            type: 'system-status',
            timestamp: timestamp
        });
    }

    /**
     * Archive old summaries (older than 2 days)
     */
    archiveOldSummaries() {
        try {
            const files = fs.readdirSync(this.writeDir);
            const twoDaysAgo = Date.now() - (2 * 24 * 60 * 60 * 1000);
            let archivedCount = 0;

            files.forEach(file => {
                if (file.endsWith('.md')) {
                    const filePath = path.join(this.writeDir, file);
                    const stats = fs.statSync(filePath);
                    
                    if (stats.mtime.getTime() < twoDaysAgo) {
                        const archivePath = path.join(this.archiveDir, file);
                        fs.renameSync(filePath, archivePath);
                        archivedCount++;
                    }
                }
            });

            if (archivedCount > 0) {
                console.log(`üì¶ Archived ${archivedCount} old summaries`);
            }

            return archivedCount;
        } catch (error) {
            console.error('‚ùå Error archiving summaries:', error.message);
            return 0;
        }
    }

    /**
     * Generate INDEX.md for the summaries directory
     */
    generateIndex() {
        try {
            const files = fs.readdirSync(this.writeDir);
            const summaryFiles = files.filter(file => file.endsWith('.md') && file !== 'INDEX.md');
            
            const indexContent = `# Summaries Index

**Generated At**: ${new Date().toISOString()}
**Total Summaries**: ${summaryFiles.length}

## Recent Summaries
${summaryFiles
    .sort((a, b) => {
        const aStat = fs.statSync(path.join(this.writeDir, a));
        const bStat = fs.statSync(path.join(this.writeDir, b));
        return bStat.mtime - aStat.mtime;
    })
    .slice(0, 20)
    .map(file => {
        const stat = fs.statSync(path.join(this.writeDir, file));
        return `- [${file}](./${file}) - ${stat.mtime.toLocaleString()}`;
    })
    .join('\n')}

## Directory Structure
- **Write Directory**: .cursor-cache/CYOPS/summaries/
- **Archive Directory**: .cursor-cache/CYOPS/summaries/.archive/
- **Routing**: GHOST 2.x Unified

---
*Auto-generated by GHOST 2.x Unified Summary Writer*
`;

            const indexPath = path.join(this.writeDir, 'INDEX.md');
            fs.writeFileSync(indexPath, indexContent, 'utf8');
            console.log('üìã Generated summaries INDEX.md');
            
            return true;
        } catch (error) {
            console.error('‚ùå Error generating index:', error.message);
            return false;
        }
    }

    /**
     * Add metadata to content
     */
    addMetadata(content, metadata) {
        const metadataBlock = `<!--
GHOST 2.x Metadata:
${Object.entries(metadata).map(([key, value]) => `${key}: ${value}`).join('\n')}
-->

`;
        
        return metadataBlock + content;
    }

    /**
     * Get summary statistics
     */
    getStats() {
        try {
            const files = fs.readdirSync(this.writeDir);
            const summaryFiles = files.filter(file => file.endsWith('.md'));
            
            const archiveFiles = fs.existsSync(this.archiveDir) ? 
                fs.readdirSync(this.archiveDir).filter(file => file.endsWith('.md')) : [];

            return {
                activeSummaries: summaryFiles.length,
                archivedSummaries: archiveFiles.length,
                totalSummaries: summaryFiles.length + archiveFiles.length,
                writeDirectory: this.writeDir,
                archiveDirectory: this.archiveDir
            };
        } catch (error) {
            return {
                error: error.message
            };
        }
    }
}

// Export singleton instance
const summaryWriter = new SummaryWriter();
export default summaryWriter;

// CLI interface
if (import.meta.url === `file://${process.argv[1]}`) {
    const command = process.argv[2];
    
    switch (command) {
        case 'index':
            summaryWriter.generateIndex();
            break;
        case 'archive':
            summaryWriter.archiveOldSummaries();
            break;
        case 'stats':
            console.log('üìä Summary Writer Stats:', summaryWriter.getStats());
            break;
        default:
            console.log('Usage: { { { { node summary-writer.js [index|archive|stats]') & &  & } >/dev/null 2>&1 & disown & } >/dev/null 2>&1 & disown} >/dev/null 2>&1 & disown} >/dev/null 2>&1 & disown;
    }
} 